/**
 ******************************************************************************
 * @file    Drivers/API/Src/API_Uart.c
 * @author  Patricio Hans HÃ¼ttmann
 * @brief   This file provides firmware functions to manage SPI peripheral
 */
/* Includes ------------------------------------------------------------------*/
#include <API_SPI.h>
#include <API_Uart.h>
#include <stdio.h>

/* SPI handler declaration */
static SPI_HandleTypeDef hspi;
void testing();

/* Private function prototypes -----------------------------------------------*/

/**
 * @brief  Initialize SPI peripheral
 * @param  none
 * @retval bool Init process status
 */
bool_t spiInit(void) {

	/*##-1- Configure the SPI peripheral ######################################*/
	hspi.Instance = SPI1;

	hspi.Init.Mode = SPI_MODE_MASTER;
	hspi.Init.Direction = SPI_DIRECTION_2LINES;
	hspi.Init.DataSize = SPI_DATASIZE_8BIT;
	hspi.Init.CLKPolarity = SPI_POLARITY_LOW; //CPOL = 0
	hspi.Init.CLKPhase = SPI_PHASE_2EDGE; //CPHA = 1
	hspi.Init.FirstBit = SPI_FIRSTBIT_MSB;
	hspi.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_64;
	hspi.Init.NSS = SPI_NSS_SOFT;

	/* Init peripheral */
	if (HAL_SPI_Init(&hspi) != HAL_OK) {
		/* Initialization Error */
		return false;
	}

//	uint8_t pSend = 0xA1;
//	char pData[20];
//	uint8_t pData = 0;

//	HAL_GPIO_WritePin(SPIx_NSS_SOFT_GPIO_PORT, SPIx_NSS_SOFT_PIN,
//			GPIO_PIN_RESET);
//	setNSS(GPIO_PIN_RESET);
//
//	if (HAL_SPI_Transmit(&hspi, (uint8_t*) &pSend, 1, HAL_MAX_DELAY) != HAL_OK)
//		return false;
//	spiSendData(&pSend, 1);
//	if (HAL_SPI_Receive(&hspi, (uint8_t*) &pData, 1, HAL_MAX_DELAY) != HAL_OK)
//		return false;
//	spiReceiveData(&pData, 1);

//	HAL_GPIO_WritePin(SPIx_NSS_SOFT_GPIO_PORT, SPIx_NSS_SOFT_PIN, GPIO_PIN_SET);
//	setNSS(GPIO_PIN_SET);

	testing();

	return true;
}

void testing() {
	uint8_t ptxSend = 0xA1;
	uint8_t prxData = 0;

	setNSS(GPIO_PIN_RESET);
	spiSendData(&ptxSend, 1);
	spiReceiveData(&prxData, 1);
	setNSS(GPIO_PIN_SET);
}

/**
 * @brief  Send data through the SPI MOSI line
 * @param  ptxData pointer to the uint8_t buffer to be sent
 * @param  size amount of data to be sent
 * @retval none
 */
void spiSendData(uint8_t *ptxData, uint16_t size) {
	/* Validate ptxData and size parameters */
	if (ptxData == NULL || size <= 0) {
		return;
	}

	HAL_SPI_Transmit(&hspi, (uint8_t*) ptxData, size, HAL_MAX_DELAY);
}

/**
 * @brief  Receive data from the SPI MISO line
 * @param  ptxData pointer to the uint8_t buffer to be sent
 * @param  size amount of data to be sent
 * @retval none
 */
void spiReceiveData(uint8_t *prxData, uint16_t size) {
	/* Validate ptxData and size parameters */
	if (prxData == NULL || size <= 0) {
		return;
	}

	HAL_SPI_Receive(&hspi, (uint8_t*) prxData, size, HAL_MAX_DELAY);
}

/**
 * @brief  Handle NSS line by software
 * @param  state set line to high or low
 * @retval none
 */
void setNSS(GPIO_PinState state) {
	HAL_GPIO_WritePin(SPIx_NSS_SOFT_GPIO_PORT, SPIx_NSS_SOFT_PIN, state);
}
